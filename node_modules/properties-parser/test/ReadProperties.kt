import java.io.*
import java.util.*

object ReadProperties {
    @Throws(IOException::class)
    fun main(args: Array<String>) {
        if (args.size <= 0) {
            System.out.println("No file provided.")
            return
        }

        val f = File(args[0])

        if (!f.exists()) {
            System.out.println("File not found: " + args[0])
            return
        }

        val prop = Properties()
        prop.load(FileInputStream(f))

        var isFirst = true // I fucking hate java, why don't they have a native string join function?
        System.out.print("{")
        for (item in prop.entrySet()) {
            val key = item.getKey() as String
            val value = item.getValue() as String

            if (isFirst) {
                isFirst = false
            } else {
                System.out.print(",")
            }

            System.out.print("\"" + escape(key) + "\":\"" + escape(value) + "\"")
        }
        System.out.print("}")
    }

    internal fun escape(s: String): String { // Taken from http://code.google.com/p/json-simple/
        val sb = StringBuffer()
        for (i in 0 until s.length()) {
            val ch = s.charAt(i)
            when (ch) {
                '"' -> sb.append("\\\"")
                '\\' -> sb.append("\\\\")
                '\b' -> sb.append("\\b")
                '\f' -> sb.append("\\f")
                '\n' -> sb.append("\\n")
                '\r' -> sb.append("\\r")
                '\t' -> sb.append("\\t")
                '/' -> sb.append("\\/")
                else ->
                    //Reference: http://www.unicode.org/versions/Unicode5.1.0/
                    if ('\u0000' <= ch && ch <= '\u001F'
                            || '\u007F' <= ch && ch <= '\u009F'
                            || '\u2000' <= ch && ch <= '\u20FF') {
                        val ss = Integer.toHexString(ch)
                        sb.append("\\u")
                        for (k in ss.length()..3) {
                            sb.append('0')
                        }
                        sb.append(ss.toUpperCase())
                    } else {
                        sb.append(ch)
                    }
            }
        }

        return sb.toString()
    }
}